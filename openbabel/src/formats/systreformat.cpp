/**********************************************************************
Copyright (C) 2004 by Chris Morley for template
Copyright (C) 2017 by Ben Bucior for Systre format

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
***********************************************************************/

#include <openbabel/babelconfig.h>
#include <openbabel/obmolecformat.h>
#include <sstream>

using namespace std;

// See http://openbabel.org/docs/dev/WritePlugins/AddFileFormat.html for more help
namespace OpenBabel
{

class SystreFormat : public OBMoleculeFormat
// Derive directly from OBFormat for objects which are not molecules.
{
public:
	//Register this format type ID in the constructor
  SystreFormat()
	{
		OBConversion::RegisterFormat("CGD",this);
		OBConversion::RegisterOptionParam("c", this, 0, OBConversion::OUTOPTIONS);
	}

	virtual const char* Description() //required
	{
		return
		"CGD format for Systre networks\n"
		"Topological network with vertices (atoms) and edges (bonds)\n"
		"Write Options e.g. -xc \n"
		"	c  Write optional edge center coordinates\n"
		;
	};

	virtual const char* SpecificationURL(){return
     "http://gavrog.org/Systre-Help.html#file_formats";};

  virtual unsigned int Flags()
  {
      return NOTREADABLE | WRITEONEONLY;
  };

 	/* This optional function is for formats which can contain more than one
	   molecule. It is used to quickly position the input stream after the nth
	   molecule without have to convert and discard all the n molecules.
	   See obconversion.cpp for details and mdlformat.cpp for an example.*/
	virtual int SkipObjects(int n, OBConversion* pConv)
	{
		return 0;
	};

	////////////////////////////////////////////////////
  /// Declarations for the "API" interface functions. Definitions are below
  // virtual bool ReadMolecule(OBBase* pOb, OBConversion* pConv);
  virtual bool WriteMolecule(OBBase* pOb, OBConversion* pConv);

private:
	/* Add declarations for any local function or member variables used.
	   Generally only a single instance of a format class is used. Keep this in
	   mind if you employ member variables. */
};
	////////////////////////////////////////////////////

//Make an instance of the format class
SystreFormat theSystreFormat;

////////////////////////////////////////////////////////////////

bool SystreFormat::WriteMolecule(OBBase* pOb, OBConversion* pConv)
{
	OBMol* pmol = dynamic_cast<OBMol*>(pOb);
	if(pmol==NULL)
		return false;

	ostream& ofs = *pConv->GetOutStream();
	/** Write the representation of the OBMol molecule to the output stream **/

	// We'll need to first extract the periodic matrix (if applicable)
	if (!pmol->IsPeriodic()) {
	    obErrorLog.ThrowError(__FUNCTION__, "Cannot export nonperiodic systems to CGD", obWarning);
	    return false;
	}
	OBUnitCell* uc = pmol->GetPeriodicLattice();

	// Write header for the molecule
	std::string indent = "  ";
	ofs << "# CGD file generated by Open Babel " << BABEL_VERSION << ", see http://openbabel.sf.net" << endl;
	ofs << "CRYSTAL" << endl;
	ofs << indent << "NAME " << pmol->GetTitle() << endl;
	ofs << indent << "GROUP P1" << endl;  // TODO: use test cases to verify that Open Babel converts everything to P1
	ofs << indent << "CELL "
	    << uc->GetA() << " "
	    << uc->GetB() << " "
	    << uc->GetC() << " "
	    << uc->GetAlpha() << " "
	    << uc->GetBeta() << " "
	    << uc->GetGamma() << endl;

	int current_node = 0;
	FOR_ATOMS_OF_MOL(a, *pmol) {
	  ++current_node;
	  vector3 frac_coords = uc->CartesianToFractional(a->GetVector());
	  ofs << indent << "NODE " << current_node
	      << " " << a->GetValence()  // coordination of the atom
	      << " " << frac_coords[0]
	      << " " << frac_coords[1]
	      << " " << frac_coords[2]
	      << endl;
	}

	std::stringstream edge_centers;
	FOR_BONDS_OF_MOL(b, *pmol) {
	  std::vector<int> bond_dir = b->GetPeriodicDirection();
	  vector3 f_add(bond_dir[0], bond_dir[1], bond_dir[2]);
	  vector3 begin = uc->CartesianToFractional(b->GetBeginAtom()->GetVector());
	  // For the second atom, we need to copy it to the correct unit cell with f_add
	  vector3 end = uc->CartesianToFractional(b->GetEndAtom()->GetVector()) + f_add;
	  ofs << indent << "EDGE  "
	      << begin[0] << " " << begin[1] << " " << begin[2] << "   "
	      << end[0] << " " << end[1] << " " << end[2] << endl;
	  // Do edge center calculation, since we already have the coordinates handy
	  edge_centers << "# EDGE_CENTER  "
	      << (begin[0] + end[0]) / 2.0 << " "
	      << (begin[1] + end[1]) / 2.0 << " "
	      << (begin[2] + end[2]) / 2.0 << endl;
	}

	if(pConv->IsOption("c")) //OBConversion::OUTOPTIONS is the default
	  ofs << edge_centers.str();

	ofs << "END" << endl;

	return true;
} //WriteMolecule

} //namespace OpenBabel

